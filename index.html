<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PADDLE QUEST</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Lilita+One&display=swap');
  html, body {
    margin: 0; padding: 0;
    background: black;
    overflow: hidden;
    font-family: 'Lilita One', cursive;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  #gameCanvas {
    display: block;
    margin: 0 auto;
    background: black;
    touch-action: none;
  }
  /* Text styling for all texts as per your spec */
  .game-text {
    color: white;
    text-shadow: 
      0 2px 1px rgba(0,0,0,1),
      -1px 0 0 black,
      1px 0 0 black,
      0 -1px 0 black,
      0 1px 0 black;
    font-weight: normal;
  }
  /* UI Screens */
  #homeScreen, #leaderboardScreen, #missionsScreen, #pauseScreen, #gameModesScreen, #challengeScreen, #challengeResultScreen {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    z-index: 10;
  }
  #homeScreen h1, #missionsScreen h1, #leaderboardScreen h1, #gameModesScreen h1, #challengeResultScreen h1, #challengeScreen h1 {
    font-size: 5vw;
    margin-bottom: 10px;
  }
  #homeScreen p {
    font-size: 2.5vw;
    margin-bottom: 30px;
  }
  button {
    font-family: 'Lilita One', cursive;
    font-size: 4vw;
    margin: 10px 0;
    padding: 12px 24px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    color: black;
    background-color: #ffd700;
    user-select: none;
    -webkit-user-select: none;
    width: 80vw;
    max-width: 300px;
  }
  button:active {
    background-color: #e6c200;
  }
  /* Back arrow button top left */
  #backArrow {
    position: fixed;
    top: 10px;
    left: 10px;
    width: 40px;
    height: 40px;
    z-index: 20;
    cursor: pointer;
  }
  #backArrow svg {
    fill: white;
    filter: drop-shadow(0 0 1px black);
  }
  /* Pause and home buttons top */
  #pauseBtn, #homeBtn {
    position: fixed;
    top: 10px;
    width: 40px;
    height: 40px;
    z-index: 20;
    cursor: pointer;
  }
  #pauseBtn { right: 60px; }
  #homeBtn { right: 10px; }
  /* Arrows at bottom for mobile */
  #leftArrow, #rightArrow {
    position: fixed;
    bottom: 10px;
    width: 70px;
    height: 70px;
    opacity: 0.75;
    user-select: none;
    -webkit-user-select: none;
    z-index: 20;
  }
  #leftArrow { left: 10px; }
  #rightArrow { right: 10px; }
  /* Pause screen text */
  #pauseScreen p {
    font-size: 3vw;
    margin-top: 10px;
  }
  /* GameModes buttons container */
  #gameModesContainer {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
    width: 90vw;
    max-width: 700px;
  }
  .gameModeBox {
    background: #222;
    border: 2px solid #ffd700;
    border-radius: 15px;
    padding: 20px;
    flex: 1 1 45%;
    min-width: 250px;
    cursor: pointer;
    user-select: none;
    transition: background 0.2s;
  }
  .gameModeBox:hover {
    background: #444;
  }
  .gameModeTitle {
    font-size: 4vw;
    margin-bottom: 10px;
  }
  .gameModeDesc {
    font-size: 2vw;
    color: #ddd;
  }
  /* Currency indicator */
  #currencyIndicator {
    position: fixed;
    top: 60px;
    right: 10px;
    color: white;
    font-size: 3vw;
    text-shadow:
      0 2px 1px rgba(0,0,0,1),
      -1px 0 0 black,
      1px 0 0 black,
      0 -1px 0 black,
      0 1px 0 black;
    z-index: 30;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #currencyIndicator img {
    width: 28px;
    height: 28px;
  }
  /* Challenge Screen */
  #challengeTimer {
    font-size: 5vw;
    margin: 20px 0;
  }
  #challengeScore {
    font-size: 4vw;
  }
</style>
</head>
<body>

<!-- Screens -->
<div id="homeScreen" class="game-text">
  <h1>Paddle Quest</h1>
  <p>Drag Paddle To Catch The Ball!</p>
  <button id="playBtn">PLAY</button>
  <button id="gameModesBtn">GAME MODES</button>
  <button id="missionsBtn">MISSIONS</button>
  <button id="leaderboardBtn">LEADERBOARD</button>
</div>

<div id="gameModesScreen" class="game-text" style="display:none;">
  <h1>Game Modes</h1>
  <div id="gameModesContainer">
    <div id="endlessModeBox" class="gameModeBox" tabindex="0">
      <div class="gameModeTitle">Endless Mode</div>
      <div class="gameModeDesc">Play until you get bored.</div>
      <button class="startModeBtn" data-mode="endless" style="margin-top:15px;">PLAY</button>
    </div>
    <div id="challengeModeBox" class="gameModeBox" tabindex="0">
      <div class="gameModeTitle">60s Challenge</div>
      <div class="gameModeDesc">Catch as many balls as you can in 60 seconds.<br>Costs 100 Puddle Points.</div>
      <button class="startModeBtn" data-mode="challenge" style="margin-top:15px;">PLAY</button>
    </div>
  </div>
</div>

<div id="missionsScreen" class="game-text" style="display:none;">
  <h1>MISSIONS</h1>
  <div id="missionsList" style="font-size: 2.5vw; margin-top: 10px; max-width: 90vw;"></div>
</div>

<div id="leaderboardScreen" class="game-text" style="display:none;">
  <h1>COMING SOON!</h1>
</div>

<div id="pauseScreen" class="game-text" style="display:none; flex-direction: column; justify-content: center; align-items: center;">
  <h1>Game Paused</h1>
  <p>Tap Anywhere To Continue</p>
</div>

<div id="challengeScreen" class="game-text" style="display:none; flex-direction: column; justify-content: center; align-items: center;">
  <h1>60s Challenge</h1>
  <div id="challengeTimer">60</div>
  <div id="challengeScore">Score: 0</div>
  <button id="leaveChallengeBtn" style="margin-top:20px; width: 60vw; max-width: 220px;">Leave Challenge</button>
</div>

<div id="challengeResultScreen" class="game-text" style="display:none; flex-direction: column; justify-content: center; align-items: center;">
  <h1 id="challengeResultTitle">Challenge Result</h1>
  <div id="challengeFinalScore" style="font-size: 4vw; margin-top: 15px;">Score: 0</div>
  <button id="challengeResultBackBtn" style="margin-top: 30px; width: 60vw; max-width: 220px;">Back to Game Modes</button>
</div>

<!-- Currency indicator -->
<div id="currencyIndicator" title="Puddle Points">
  <img src="https://i.imgur.com/6Xdyv8r.png" alt="Puddle Points" />
  <div id="puddlePointsDisplay">0</div>
</div>

<!-- Canvas -->
<canvas id="gameCanvas"></canvas>

<!-- Controls -->
<div id="backArrow" style="display:none;" title="Back">
  <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6" stroke="white" stroke-width="2" fill="none" stroke-linejoin="round"/></svg>
</div>
<div id="pauseBtn" title="Pause">
  <svg viewBox="0 0 24 24" width="40" height="40" fill="white" filter="drop-shadow(0 0 1px black)">
    <rect x="6" y="4" width="4" height="16"></rect>
    <rect x="14" y="4" width="4" height="16"></rect>
  </svg>
</div>
<div id="homeBtn" title="Home">
  <svg viewBox="0 0 24 24" width="40" height="40" fill="white" filter="drop-shadow(0 0 1px black)">
    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-5H9v5a2 2 0 0 1-2 2H3z"/>
  </svg>
</div>
<div id="leftArrow" title="Move Left">
  <svg viewBox="0 0 24 24" width="70" height="70" fill="white" filter="drop-shadow(0 0 1px black)">
    <path d="M15 18l-6-6 6-6"/>
  </svg>
</div>
<div id="rightArrow" title="Move Right">
  <svg viewBox="0 0 24 24" width="70" height="70" fill="white" filter="drop-shadow(0 0 1px black)">
    <path d="M9 18l6-6-6-6"/>
  </svg>
</div>

<script>
// Canvas setup & resizing
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let W, H;
function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
}
resize();
window.addEventListener("resize", resize);

// Text style function for all game texts
function drawStyledText(text, x, y, align = "left", fontSize = 48) {
  ctx.font = `${fontSize}px 'Lilita One', cursive`;
  ctx.textAlign = align;
  ctx.lineWidth = 8;
  ctx.strokeStyle = "black";
  ctx.shadowColor = "black";
  ctx.shadowBlur = 1;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 2;
  ctx.strokeText(text, x, y);
  ctx.fillStyle = "white";
  ctx.fillText(text, x, y);
}

// Starfield parallax background setup
const starLayers = [
  { stars: [], speed: 0.15, size: 1, count: 80 },
  { stars: [], speed: 0.4, size: 2, count: 40 },
  { stars: [], speed: 0.7, size: 3, count: 20 }
];

function initStarfield() {
  starLayers.forEach(layer => {
    layer.stars = [];
    for (let i = 0; i < layer.count; i++) {
      layer.stars.push({
        x: Math.random() * W,
        y: Math.random() * H,
        size: layer.size
      });
    }
  });
}
initStarfield();

function updateStarfield() {
  starLayers.forEach(layer => {
    layer.stars.forEach(star => {
      star.y += layer.speed;
      if (star.y > H) star.y = 0;
    });
  });
}
function drawStarfield() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, W, H);
  starLayers.forEach(layer => {
    ctx.fillStyle = "white";
    layer.stars.forEach(star => {
      ctx.fillRect(star.x, star.y, star.size, star.size);
    });
  });
}

// Spark particle system for ball collisions
const sparks = [];
function createSparks(x, y) {
  for (let i = 0; i < 10; i++) {
    sparks.push({
      x: x,
      y: y,
      dx: (Math.random() - 0.5) * 5,
      dy: (Math.random() - 0.5) * 5,
      life: 25
    });
  }
}
function updateSparks() {
  for (let i = sparks.length - 1; i >= 0; i--) {
    const s = sparks[i];
    s.x += s.dx;
    s.y += s.dy;
    s.life--;
    if (s.life <= 0) sparks.splice(i, 1);
  }
}
function drawSparks() {
  ctx.fillStyle = "white";
  sparks.forEach(s => {
    ctx.fillRect(s.x, s.y, 2, 2);
  });
}

// Game variables (shared across modes)
const paddle = {
  width: W * 0.2,
  height: 20,
  x: W / 2 - (W * 0.2) / 2,
  y: H - 50,
  speed: 10,
  dx: 0
};

const ball = {
  x: W / 2,
  y: H / 2,
  size: 12,
  speedX: 5,
  speedY: 5
};

let score = 0;
let highScore = parseInt(localStorage.getItem("paddleQuestHighScore")) || 0;
let puddlePoints = parseInt(localStorage.getItem("paddleQuestPuddlePoints")) || 0;
let isPaused = false;
let isPlaying = false;
let currentMode = null; // "endless" or "challenge"

// UI Elements
const homeScreen = document.getElementById("homeScreen");
const gameModesScreen = document.getElementById("gameModesScreen");
const missionsScreen = document.getElementById("missionsScreen");
const leaderboardScreen = document.getElementById("leaderboardScreen");
const pauseScreen = document.getElementById("pauseScreen");
const challengeScreen = document.getElementById("challengeScreen");
const challengeResultScreen = document.getElementById("challengeResultScreen");

const playBtn = document.getElementById("playBtn");
const gameModesBtn = document.getElementById("gameModesBtn");
const missionsBtn = document.getElementById("missionsBtn");
const leaderboardBtn = document.getElementById("leaderboardBtn");
const backArrow = document.getElementById("backArrow");
const pauseBtn = document.getElementById("pauseBtn");
const homeBtn = document.getElementById("homeBtn");
const leftArrow = document.getElementById("leftArrow");
const rightArrow = document.getElementById("rightArrow");
const puddlePointsDisplay = document.getElementById("puddlePointsDisplay");

const challengeTimerDisplay = document.getElementById("challengeTimer");
const challengeScoreDisplay = document.getElementById("challengeScore");
const leaveChallengeBtn = document.getElementById("leaveChallengeBtn");
const challengeResultTitle = document.getElementById("challengeResultTitle");
const challengeFinalScore = document.getElementById("challengeFinalScore");
const challengeResultBackBtn = document.getElementById("challengeResultBackBtn");

const startModeButtons = document.querySelectorAll(".startModeBtn");

// Missions System (simple daily repeating 5 missions)
const missionsList = document.getElementById("missionsList");
const missionsData = [
  { id: 1, text: "Catch 5 balls", goal: 5, progress: 0, done: false, reward: 50 },
  { id: 2, text: "Catch 10 balls", goal: 10, progress: 0, done: false, reward: 50 },
  { id: 3, text: "Score 20 points", goal: 20, progress: 0, done: false, reward: 50 },
  { id: 4, text: "Score 30 points", goal: 30, progress: 0, done: false, reward: 50 },
  { id: 5, text: "Play for 60 seconds", goal: 60, progress: 0, done: false, timeMission: true, reward: 50 }
];

function resetMissions() {
  missionsData.forEach(m => {
    m.progress = 0;
    m.done =
    false;
  });
  saveMissions();
  updateMissions();
}

function saveMissions() {
  localStorage.setItem("paddleQuestMissions", JSON.stringify(missionsData));
}

function loadMissions() {
  const saved = localStorage.getItem("paddleQuestMissions");
  if (saved) {
    const loaded = JSON.parse(saved);
    loaded.forEach(savedMission => {
      const mission = missionsData.find(m => m.id === savedMission.id);
      if (mission) {
        mission.progress = savedMission.progress;
        mission.done = savedMission.done;
      }
    });
  }
}

function updateMissions() {
  missionsList.innerHTML = "";
  missionsData.forEach(m => {
    const missionDiv = document.createElement("div");
    missionDiv.style.marginBottom = "15px";
    missionDiv.style.color = m.done ? "#0f0" : "#fff";
    missionDiv.textContent = `${m.text} (${m.progress}/${m.goal})`;
    missionsList.appendChild(missionDiv);
  });
}

// Update puddle points display
function updatePuddlePointsDisplay() {
  puddlePointsDisplay.textContent = puddlePoints;
}

// Check mission completion and reward
function checkMissions() {
  missionsData.forEach(m => {
    if (!m.done && m.progress >= m.goal) {
      m.done = true;
      puddlePoints += m.reward;
      updatePuddlePointsDisplay();
      savePuddlePoints();
      saveMissions();
    }
  });
}

// Save puddle points
function savePuddlePoints() {
  localStorage.setItem("paddleQuestPuddlePoints", puddlePoints);
}

// Show only one screen, hide others
function showScreen(name) {
  const screens = [homeScreen, gameModesScreen, missionsScreen, leaderboardScreen, pauseScreen, challengeScreen, challengeResultScreen];
  screens.forEach(screen => {
    if (screen === window[name + "Screen"]) {
      screen.style.display = "flex";
    } else {
      screen.style.display = "none";
    }
  });
  // Show/hide back arrow except on home
  backArrow.style.display = (name && name !== "home") ? "block" : "none";
  // Show/hide game canvas and controls only during gameplay modes
  const gameplayActive = (name === null);
  canvas.style.display = gameplayActive ? "block" : "none";
  leftArrow.style.display = gameplayActive ? "block" : "none";
  rightArrow.style.display = gameplayActive ? "block" : "none";
  pauseBtn.style.display = gameplayActive ? "block" : "none";
  homeBtn.style.display = gameplayActive ? "block" : "none";

  // Show currency indicator everywhere except pause screen and challenge result
  if (name === "pause" || name === "challengeResult") {
    document.getElementById("currencyIndicator").style.display = "none";
  } else {
    document.getElementById("currencyIndicator").style.display = "flex";
  }
}

// Game variables for gameplay modes
let gameStartTime = 0;
let challengeTimeLeft = 60;
let challengeInterval = null;

// Start game in chosen mode
function startGame(mode) {
  isPlaying = true;
  isPaused = false;
  score = 0;
  currentMode = mode;
  ball.x = W / 2;
  ball.y = H / 2;
  ball.speedX = 5;
  ball.speedY = 5;
  paddle.width = W * 0.2;
  paddle.x = W / 2 - paddle.width / 2;
  paddle.y = H - 50;

  if (mode === "challenge") {
    // Deduct 100 points, check first
    if (puddlePoints < 100) {
      alert("Not enough Puddle Points to play 60s Challenge!");
      showScreen("gameModes");
      isPlaying = false;
      return;
    }
    puddlePoints -= 100;
    savePuddlePoints();
    updatePuddlePointsDisplay();

    challengeTimeLeft = 60;
    challengeScoreDisplay.textContent = "Score: 0";
    challengeTimerDisplay.textContent = challengeTimeLeft;
    showScreen("challenge");
    gameStartTime = Date.now();

    challengeInterval = setInterval(() => {
      challengeTimeLeft--;
      challengeTimerDisplay.textContent = challengeTimeLeft;
      if (challengeTimeLeft <= 0) {
        clearInterval(challengeInterval);
        endChallenge(true);
      }
    }, 1000);
  } else {
    // Endless mode
    showScreen(null);
    gameStartTime = Date.now();
  }
  loop();
}

// End challenge: success or fail
function endChallenge(success) {
  isPlaying = false;
  clearInterval(challengeInterval);
  showScreen("challengeResult");
  challengeResultTitle.textContent = success ? "Challenge Completed!" : "Challenge Failed!";
  challengeFinalScore.textContent = `Score: ${score}`;
  // Update high score if needed (for endless only)
  if (success && score > highScore) {
    highScore = score;
    localStorage.setItem("paddleQuestHighScore", highScore);
  }
}

// Leave challenge early - counts as fail
leaveChallengeBtn.onclick = () => {
  endChallenge(false);
};

// Back button on challenge result screen
challengeResultBackBtn.onclick = () => {
  showScreen("gameModes");
};

// Back arrow navigation
backArrow.onclick = () => {
  // If in missions or leaderboard or gameModes, go back home
  if (missionsScreen.style.display === "flex" ||
      leaderboardScreen.style.display === "flex" ||
      gameModesScreen.style.display === "flex" ||
      challengeResultScreen.style.display === "flex" ||
      challengeScreen.style.display === "flex") {
    showScreen("home");
  }
  // Hide back arrow if now on home
  backArrow.style.display = "none";
};

// Home button stops game and goes home
homeBtn.onclick = () => {
  stopGame();
  showScreen("home");
};

// Pause button toggles pause
pauseBtn.onclick = () => {
  if (!isPlaying) return;
  isPaused = !isPaused;
  if (isPaused) {
    showScreen("pause");
  } else {
    showScreen(null);
    loop();
  }
};

// Stop game helper
function stopGame() {
  isPlaying = false;
  isPaused = false;
  clearInterval(challengeInterval);
}

// Arrow button controls
let leftPressed = false;
let rightPressed = false;

leftArrow.addEventListener("touchstart", e => {
  e.preventDefault();
  leftPressed = true;
});
leftArrow.addEventListener("touchend", e => {
  e.preventDefault();
  leftPressed = false;
});
rightArrow.addEventListener("touchstart", e => {
  e.preventDefault();
  rightPressed = true;
});
rightArrow.addEventListener("touchend", e => {
  e.preventDefault();
  rightPressed = false;
});
leftArrow.addEventListener("mousedown", e => {
  e.preventDefault();
  leftPressed = true;
});
leftArrow.addEventListener("mouseup", e => {
  e.preventDefault();
  leftPressed = false;
});
rightArrow.addEventListener("mousedown", e => {
  e.preventDefault();
  rightPressed = true;
});
rightArrow.addEventListener("mouseup", e => {
  e.preventDefault();
  rightPressed = false;
});

// Movement and gameplay functions
function movePaddle() {
  if (leftPressed) {
    paddle.x -= paddle.speed;
    if (paddle.x < 0) paddle.x = 0;
  }
  if (rightPressed) {
    paddle.x += paddle.speed;
    if (paddle.x + paddle.width > W) paddle.x = W - paddle.width;
  }
}

function updateBall() {
  ball.x += ball.speedX;
  ball.y += ball.speedY;

  // Increase speed gradually in endless
  if (currentMode === "endless") {
    ball.speedX *= 1.0005;
    ball.speedY *= 1.0005;
  }
}

function checkCollision() {
  if (
    ball.y + ball.size >= paddle.y &&
    ball.x > paddle.x &&
    ball.x < paddle.x + paddle.width &&
    ball.speedY > 0
  ) {
    ball.speedY = -ball.speedY;
    score++;
    if (score > highScore) {
      highScore = score;
      localStorage.setItem("paddleQuestHighScore", highScore);
    }
    createSparks(ball.x, ball.y);

    // Increase speed slightly
    ball.speedX *= 1.03;
    ball.speedY *= 1.03;
  }
}

function checkWalls() {
  if (ball.x + ball.size > W || ball.x - ball.size < 0) {
    ball.speedX = -ball.speedX;
    createSparks(ball.x, ball.y);
  }
  if (ball.y - ball.size < 0) {
    ball.speedY = -ball.speedY;
    createSparks(ball.x, ball.y);
  }
  if (ball.y + ball.size > H) {
    if (currentMode === "endless") {
      stopGame();
      saveMissions();
      showScreen("home");
    } else if (currentMode === "challenge") {
      // In challenge mode, missing the ball does not end game
      ball.speedY = -ball.speedY; // just bounce it back up
      createSparks(ball.x, ball.y);
    }
  }
}

// Drawing functions
function drawPaddle() {
  ctx.fillStyle = "white";
  ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
  ctx.closePath();
}

function drawScore() {
  drawStyledText(`Score: ${score}`, 20, 50, "left", 48);
  drawStyledText(`High Score: ${highScore}`, W - 20, 50, "right", 36);
  if (currentMode === "challenge") {
    challengeScoreDisplay.textContent = `Score: ${score}`;
  }
}

function loop() {
  if (!isPlaying || isPaused) return;

  updateStarfield();
  drawStarfield();

  movePaddle();
  updateBall();
  checkCollision();
  checkWalls();

  drawPaddle();
  drawBall();
  updateSparks();
  drawSparks();
  drawScore();

  // Missions progress update for time mission
  if (missionsData[4].timeMission && isPlaying) {
    const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
    missionsData[4].progress = Math.min(elapsed, missionsData[4].goal);
    checkMissions();
    updateMissions();
  }

  // Challenge mode timer score update
  if (currentMode === "challenge") {
    // Score increases by catching balls, handled in checkCollision()
  }

  requestAnimationFrame(loop);
}

// Load saved missions and puddle points on start
loadMissions();
updateMissions();
updatePuddlePointsDisplay();

// Button event handlers
playBtn.onclick = () => {
  startGame("endless");
};
gameModesBtn.onclick = () => {
  showScreen("gameModes");
};
missionsBtn.onclick = () => {
  showScreen("missions");
};
leaderboardBtn.onclick = () => {
  showScreen("leaderboard");
};

startModeButtons.forEach(btn => {
  btn.onclick = () => {
    const mode = btn.getAttribute("data-mode");
    startGame(mode);
  };
});

// Prevent default scrolling on arrows
[leftArrow, rightArrow].forEach(arrow => {
  arrow.addEventListener("touchstart", e => e.preventDefault());
  arrow.addEventListener("touchend", e => e.preventDefault());
});

// Pause screen click to resume
pauseScreen.addEventListener("click", () => {
  if (isPaused) {
    isPaused = false;
    showScreen(null);
    loop();
  }
});

// Prevent text selection everywhere
document.body.style.userSelect = "none";
document.body.style.webkitUserSelect = "none";

// Mission reset daily on load
(function dailyReset() {
  const today = new Date().toDateString();
  const lastReset = localStorage.getItem("paddleQuestMissionsLastReset");
  if (lastReset !== today) {
    resetMissions();
    localStorage.setItem("paddleQuestMissionsLastReset", today);
  } else {
    loadMissions();
    updateMissions();
  }
})();

// Save on exit
window.addEventListener("beforeunload", () => {
  saveMissions();
  savePuddlePoints();
  localStorage.setItem("paddleQuestHighScore", highScore);
});
</script>

</body>
</html>
