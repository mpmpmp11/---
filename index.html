<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>PADDLE QUEST</title>

<!-- Lilita One font (regular) -->
<link href="https://fonts.googleapis.com/css2?family=Lilita+One&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#13244b;
    --white: #ffffff;
    --accent-yellow: #ffd24a;
    --ui-radius: 14px;
    /* Text style variables (applied to all texts) */
    --font-family: "Lilita One", sans-serif;
    --text-color: var(--white);
    /* Outline and shadow — tuned to be strong and readable on mobile.
       If you truly want crazy 50px outline, change --outline to 50px. */
    --outline: 3px;
    --shadow-opacity: 1.0; /* 1.0 equals 100% */
    --shadow-blur: 1px;
    --shadow-x: 0px;
    --shadow-y: 2px;
  }

  html,body{
    height:100%;
    margin:0;
    background: linear-gradient(180deg,#071226 0%, #081427 60%, #08121f 100%);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    font-family:var(--font-family);
    color:var(--text-color);
    overflow:hidden;
  }

  /* Global text style for all UI text elements */
  .ui-text, .title, button, .overlay-text {
    font-family: var(--font-family);
    color: var(--text-color);
    /* outline using webkit stroke for crisp border + fallback text-shadow stack */
    -webkit-text-stroke: var(--outline) black;
    text-shadow:
      var(--shadow-x) var(--shadow-y) var(--shadow-blur) rgba(0,0,0,var(--shadow-opacity)),
      0 0 0 rgba(0,0,0,0.0);
    -webkit-user-select: none;
    user-select: none;
  }

  /* App container */
  #app {
    position:relative;
    width:100vw;
    height:100vh;
    box-sizing:border-box;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  /* Canvas wrapper ensures safe spacing from Android nav bars */
  #game-area {
    position:relative;
    width:100%;
    height:100%;
    max-width:1000px; /* keep sane wide display */
    max-height:1000px;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  canvas#gameCanvas{
    background: linear-gradient(180deg, rgba(10,20,35,0.2), rgba(0,0,0,0.2));
    width:100%;
    height:100%;
    display:block;
    touch-action:none;
  }

  /* UI overlay on top of canvas */
  .hud {
    position:absolute;
    inset:0;
    pointer-events:none; /* allow canvas touches, except where pointer-events enabled */
  }

  /* Top bar: score & highscore */
  .top-left, .top-right {
    position:absolute;
    top: calc(10px + env(safe-area-inset-top));
    left:10px;
    right:auto;
    pointer-events:none;
  }
  .top-right { left:auto; right:10px; }

  .score-box {
    pointer-events:none;
    background: rgba(0,0,0,0.2);
    padding:6px 10px;
    border-radius:10px;
    backdrop-filter: blur(2px);
  }
  .score-label { font-size:16px; }
  .score-value { font-size:20px; }

  /* Buttons area (bottom) with left/right arrows and UI buttons */
  .controls {
    position:absolute;
    left:0;
    right:0;
    bottom: calc(22px + env(safe-area-inset-bottom)); /* keep above nav bar */
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding: 0 16px;
    pointer-events:none; /* buttons inside will enable pointer */
    gap:10px;
  }

  .left-right {
    display:flex;
    gap:18px;
    align-items:center;
    pointer-events:auto;
  }

  .arrow-btn {
    width:72px;
    height:72px;
    border-radius:16px;
    background: rgba(255,255,255,0.06);
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 6px 18px rgba(0,0,0,0.4);
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
    user-select:none;
  }

  .arrow-icon {
    font-size:34px;
    line-height:1;
    color:var(--white);
    transform:translateY(2px);
  }

  /* Center controls (pause/home) */
  .center-controls {
    display:flex;
    gap:12px;
    pointer-events:auto;
  }
  .icon-btn {
    min-width:56px;
    min-height:56px;
    border-radius:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(255,255,255,0.06);
    -webkit-tap-highlight-color: transparent;
  }

  /* Home / menus UI screens (cover canvas) */
  .screen {
    position:absolute;
    inset:0;
    display:flex;
    flex-direction:column;
    gap:16px;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg, rgba(3,6,10,0.6), rgba(3,6,10,0.4));
    pointer-events:auto;
  }

  .title {
    font-size:46px;
    letter-spacing:1px;
    text-align:center;
    margin-top: 30px;
  }

  .subtitle {
    font-size:16px;
    opacity:0.95;
    margin-top:8px;
  }

  .menu-buttons {
    display:flex;
    flex-direction:column;
    gap:12px;
    margin-top:18px;
  }

  .btn {
    min-width:220px;
    padding:14px 24px;
    border-radius:12px;
    font-size:20px;
    cursor:pointer;
    pointer-events:auto;
    border:none;
    outline:none;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    display:flex;
    justify-content:center;
    align-items:center;
    gap:10px;
  }

  .btn-play {
    background: linear-gradient(180deg, #ffd24a, #f2b21a);
    color:#081217;
  }
  .btn-gray {
    background: rgba(255,255,255,0.06);
    color:var(--white);
  }

  .small-note { font-size:13px; opacity:0.95; }

  /* Missions list */
  .missions-list {
    width:90%;
    max-width:440px;
    background: rgba(255,255,255,0.02);
    border-radius:12px;
    padding:12px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.5);
  }
  .mission {
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:8px;
    gap:10px;
  }
  .mission .m-title { font-size:16px; }
  .mission .m-progress { font-size:14px; opacity:0.95; }

  /* Overlay for pause / messages */
  .overlay {
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.5);
    pointer-events:auto;
    z-index:50;
  }
  .overlay.show { display:flex; }
  .overlay-text {
    text-align:center;
    font-size:30px;
    margin-bottom:12px;
  }
  .overlay-small { font-size:14px; }

  /* Top-left back button */
  .back-btn {
    position:absolute;
    top: calc(10px + env(safe-area-inset-top));
    left:10px;
    pointer-events:auto;
    width:46px;
    height:46px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:10px;
    background: rgba(255,255,255,0.03);
  }

  /* "COMING SOON" and small screens */
  .coming-soon {
    font-size:20px;
    text-align:center;
    padding:8px 12px;
    border-radius:10px;
    background: rgba(255,255,255,0.03);
  }

  /* small adjustments for very small screens */
  @media (max-height:500px){
    .arrow-btn { width:60px;height:60px; }
    .title{ font-size:38px; }
  }

</style>
</head>
<body>
<div id="app">
  <div id="game-area">
    <!-- Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD overlay -->
    <div class="hud" id="hud">

      <!-- Top-left score -->
      <div class="top-left">
        <div class="score-box ui-text">
          <div class="score-label">SCORE</div>
          <div class="score-value" id="scoreValue">0</div>
        </div>
      </div>

      <!-- Top-right highscore -->
      <div class="top-right">
        <div class="score-box ui-text">
          <div class="score-label">HIGH</div>
          <div class="score-value" id="highValue">0</div>
        </div>
      </div>

      <!-- Back button top-left (for menus) -->
      <div class="back-btn ui-text" id="backBtn" title="Back" style="display:none;">
        ←
      </div>

      <!-- Controls bottom -->
      <div class="controls">
        <div class="left-right">
          <div class="arrow-btn" id="leftBtn" role="button" aria-label="Move left">
            <div class="arrow-icon">◀</div>
          </div>
          <div class="arrow-btn" id="rightBtn" role="button" aria-label="Move right">
            <div class="arrow-icon">▶</div>
          </div>
        </div>

        <div class="center-controls">
          <div class="icon-btn" id="pauseBtn" title="Pause">II</div>
          <div class="icon-btn" id="homeBtn" title="Home">⌂</div>
        </div>
      </div>

      <!-- Pause / message overlay -->
      <div class="overlay ui-text" id="pauseOverlay">
        <div style="text-align:center;">
          <div class="overlay-text">Game Paused</div>
          <div class="overlay-small">Tap Anywhere To Continue</div>
        </div>
      </div>

      <!-- Screens: home, leaderboard, missions -->
      <div class="screen" id="homeScreen">
        <div style="text-align:center;">
          <div class="title ui-text">Paddle Quest</div>
          <div class="subtitle ui-text">Drag Paddle To Catch The Ball!</div>
        </div>

        <div class="menu-buttons">
          <button class="btn btn-play ui-text" id="playBtn">PLAY</button>
          <button class="btn btn-gray ui-text" id="leaderBtn">Leaderboard</button>
          <button class="btn btn-gray ui-text" id="missionsBtn">MISSIONS</button>
        </div>

        <div style="position:absolute;bottom:10px; font-size:12px; opacity:0.9;" class="ui-text">
          © Paddle Quest
        </div>
      </div>

      <div class="screen" id="leaderScreen" style="display:none;">
        <div class="title ui-text">Leaderboard</div>
        <div class="coming-soon ui-text">COMING SOON!</div>
      </div>

      <div class="screen" id="missionsScreen" style="display:none;">
        <div class="title ui-text">MISSIONS</div>

        <div class="missions-list ui-text" id="missionsList">
          <!-- Missions dynamically populated -->
        </div>
        <div style="margin-top:8px;" class="ui-text small-note">Missions reset daily.</div>
      </div>

    </div>
  </div>
</div>

<script>
/*
  PADDLE QUEST - Single file HTML game
  Mobile-first, touch friendly.

  Features:
  - Ball falls from top and bounces off walls & paddle
  - Paddle controlled by left/right on-screen buttons (hold to move)
  - Score & highscore (localStorage)
  - Pause, Home, Leaderboard (COMING SOON), Missions (5 daily tasks)
  - Pause overlay and Home return behavior
  - Text styles applied globally via CSS
*/

(() => {
  // -- Canvas setup with devicePixelRatio scaling --
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas(){
    // make canvas fill parent, but use devicePixelRatio scaling for crispness
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(320, Math.floor(rect.width * dpr));
    canvas.height = Math.max(480, Math.floor(rect.height * dpr));
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // ensure canvas parent fills viewport
  function fitCanvasToViewport(){
    const gameArea = document.getElementById('game-area');
    // set game area full screen
    gameArea.style.width = window.innerWidth + 'px';
    gameArea.style.height = window.innerHeight + 'px';
  }

  function initSizes(){
    fitCanvasToViewport();
    resizeCanvas();
  }

  window.addEventListener('resize', () => {
    initSizes();
    drawImmediate();
  });

  // initialize once
  initSizes();

  // -- Game state --
  const state = {
    running: false,
    paused: false,
    inMenu: true,
    screen: 'home', // 'home', 'game', 'leader', 'missions'
    score: 0,
    high: 0,
    lastTime: null,
    paddle: {
      x: 0, // center x
      y: 0, // top y
      width: 120,
      height: 18,
      speed: 520 // px per second when holding
    },
    ball: {
      x: 150,
      y: 100,
      r: 12,
      vx: 90,
      vy: 200,
      speedMultiplier: 1
    },
    controls: {
      left: false,
      right: false
    },
    missions: []
  };

  // -- UI elements --
  const scoreValue = document.getElementById('scoreValue');
  const highValue = document.getElementById('highValue');
  const homeScreen = document.getElementById('homeScreen');
  const leaderScreen = document.getElementById('leaderScreen');
  const missionsScreen = document.getElementById('missionsScreen');
  const backBtn = document.getElementById('backBtn');
  const pauseOverlay = document.getElementById('pauseOverlay');

  // Buttons
  const playBtn = document.getElementById('playBtn');
  const leaderBtn = document.getElementById('leaderBtn');
  const missionsBtn = document.getElementById('missionsBtn');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const homeBtn = document.getElementById('homeBtn');

  // Load highscore & initialize missions
  const LS_PREFIX = 'paddlequest_v1_';
  state.high = parseInt(localStorage.getItem(LS_PREFIX + 'highscore')) || 0;
  highValue.textContent = state.high;

  // Missions: example five missions (easy numeric goals), progress tracked and resets daily
  function initMissionsFromStorage(){
    const today = new Date().toISOString().slice(0,10); // YYYY-MM-DD
    const savedDate = localStorage.getItem(LS_PREFIX + 'missions_date');
    if (savedDate !== today){
      // reset missions
      const tasks = [
        { id:1, title:'Catch 1 ball', target:1, progress:0, claimed:false },
        { id:2, title:'Catch 3 balls', target:3, progress:0, claimed:false },
        { id:3, title:'Get 5 score', target:5, progress:0, claimed:false },
        { id:4, title:'Catch 10 balls', target:10, progress:0, claimed:false },
        { id:5, title:'Play 1 game', target:1, progress:0, claimed:false }
      ];
      state.missions = tasks;
      localStorage.setItem(LS_PREFIX + 'missions_date', today);
      localStorage.setItem(LS_PREFIX + 'missions_data', JSON.stringify(tasks));
    } else {
      const saved = localStorage.getItem(LS_PREFIX + 'missions_data');
      if (saved){
        try {
          state.missions = JSON.parse(saved);
        } catch(e){
          console.warn('missions parse err', e);
          initMissionsFromStorage(); // fallback to reset
        }
      } else {
        initMissionsFromStorage();
      }
    }
    renderMissions();
  }

  function saveMissions(){
    localStorage.setItem(LS_PREFIX + 'missions_data', JSON.stringify(state.missions));
  }

  function renderMissions(){
    const list = document.getElementById('missionsList');
    list.innerHTML = '';
    for (const m of state.missions){
      const row = document.createElement('div');
      row.className = 'mission ui-text';
      const left = document.createElement('div');
      left.innerHTML = `<div class="m-title">${m.title}</div><div class="m-progress">${m.progress}/${m.target}</div>`;
      const right = document.createElement('div');
      right.innerHTML = m.claimed ? 'CLAIMED' : (m.progress >= m.target ? '<button class="btn btn-play claim-btn">CLAIM</button>' : 'locked');
      row.appendChild(left);
      row.appendChild(right);
      list.appendChild(row);
      if (!m.claimed && m.progress >= m.target){
        const btn = row.querySelector('.claim-btn');
        if (btn){
          btn.addEventListener('click', ()=>{
            m.claimed = true;
            saveMissions();
            renderMissions();
            // reward: increment high score by 1 (example)
            state.high = Math.max(state.high, state.score);
            localStorage.setItem(LS_PREFIX + 'highscore', state.high);
            highValue.textContent = state.high;
          });
        }
      }
    }
  }

  initMissionsFromStorage();

  // -- Game initialization --
  function startGame(){
    // reset state
    state.score = 0;
    state.ball.x = canvas.width/4;
    state.ball.y = 40;
    state.ball.vx = 90;
    state.ball.vy = 200;
    state.ball.speedMultiplier = 1;
    // paddle center bottom
    state.paddle.width = Math.max(80, canvas.getBoundingClientRect().width * 0.26);
    state.paddle.height = 18;
    state.paddle.x = (canvas.getBoundingClientRect().width - state.paddle.width) / 2;
    state.paddle.y = canvas.getBoundingClientRect().height - 90; // above controls
    state.running = true;
    state.paused = false;
    state.lastTime = performance.now();
    showScreen('game');
    requestAnimationFrame(gameLoop);
  }

  function endGame(){
    state.running = false;
    // update highscore & store
    if (state.score > state.high){
      state.high = state.score;
      localStorage.setItem(LS_PREFIX + 'highscore', state.high);
      highValue.textContent = state.high;
    }
    // When game ends, return to home screen
    showScreen('home');
  }

  // -- UI navigation --
  function showScreen(screenName){
    state.screen = screenName;
    // hide overlays
    pauseOverlay.classList.remove('show');
    backBtn.style.display = 'none';

    if (screenName === 'home'){
      homeScreen.style.display = 'flex';
      leaderScreen.style.display = 'none';
      missionsScreen.style.display = 'none';
      state.inMenu = true;
      state.running = false;
    } else if (screenName === 'leader'){
      homeScreen.style.display = 'none';
      leaderScreen.style.display = 'flex';
      missionsScreen.style.display = 'none';
      state.inMenu = true;
      backBtn.style.display = 'flex';
    } else if (screenName === 'missions'){
      homeScreen.style.display = 'none';
      leaderScreen.style.display = 'none';
      missionsScreen.style.display = 'flex';
      state.inMenu = true;
      backBtn.style.display = 'flex';
    } else if (screenName === 'game'){
      homeScreen.style.display = 'none';
      leaderScreen.style.display = 'none';
      missionsScreen.style.display = 'none';
      state.inMenu = false;
      backBtn.style.display = 'none';
    }
  }

  // initial screen
  showScreen('home');

  // -- Input handling for left/right hold behavior --
  function setControl(key, val){
    state.controls[key] = val;
  }

  // For pointer-based hold/ release:
  function attachHold(buttonEl, key){
    // support pointer events
    buttonEl.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      buttonEl.setPointerCapture(e.pointerId);
      setControl(key, true);
    }, {passive:false});

    buttonEl.addEventListener('pointerup', (e)=>{
      e.preventDefault();
      try{ buttonEl.releasePointerCapture(e.pointerId); }catch(e){}
      setControl(key, false);
    }, {passive:false});

    buttonEl.addEventListener('pointercancel', (e)=>{
      e.preventDefault();
      setControl(key, false);
    }, {passive:false});

    // also stop dragging from triggering ghost browser behavior
    buttonEl.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
  }

  attachHold(leftBtn, 'left');
  attachHold(rightBtn, 'right');

  // Pause button (toggle)
  pauseBtn.addEventListener('click', ()=>{
    if (!state.running) return;
    state.paused = !state.paused;
    if (state.paused){
      pauseOverlay.classList.add('show');
    } else {
      pauseOverlay.classList.remove('show');
      state.lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }
  });

  // Pause overlay tap to unpause
  pauseOverlay.addEventListener('pointerdown', ()=>{
    if (!state.running) return;
    state.paused = false;
    pauseOverlay.classList.remove('show');
    state.lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  });

  // Home during gameplay
  homeBtn.addEventListener('click', ()=>{
    if (state.running){
      state.running = false;
      showScreen('home');
    } else {
      showScreen('home');
    }
  });

  // Menu buttons
  playBtn.addEventListener('click', ()=>{
    startGame();
  });

  leaderBtn.addEventListener('click', ()=>{
    showScreen('leader');
  });

  missionsBtn.addEventListener('click', ()=>{
    initMissionsFromStorage();
    showScreen('missions');
  });

  backBtn.addEventListener('click', ()=>{
    // go back to home
    showScreen('home');
  });

  // Pause by keyboard for desktop testing
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'p'){
      pauseBtn.click();
    }
  });

  // -- Game mechanics --
  function update(dt){
    // paddle movement via held controls
    const speed = state.paddle.speed;
    if (state.controls.left && !state.controls.right){
      state.paddle.x -= speed * dt;
    } else if (state.controls.right && !state.controls.left){
      state.paddle.x += speed * dt;
    }

    // clamp paddle inside canvas width
    const rect = canvas.getBoundingClientRect();
    const paddleLeftBound = 6;
    const paddleRightBound = rect.width - state.paddle.width - 6;
    if (state.paddle.x < paddleLeftBound) state.paddle.x = paddleLeftBound;
    if (state.paddle.x > paddleRightBound) state.paddle.x = paddleRightBound;

    // ball physics
    state.ball.x += state.ball.vx * dt * state.ball.speedMultiplier;
    state.ball.y += state.ball.vy * dt * state.ball.speedMultiplier;

    // walls bounce (left & right)
    if (state.ball.x - state.ball.r < 0){
      state.ball.x = state.ball.r;
      state.ball.vx *= -1;
    } else if (state.ball.x + state.ball.r > rect.width){
      state.ball.x = rect.width - state.ball.r;
      state.ball.vx *= -1;
    }

    // top bounce
    if (state.ball.y - state.ball.r < 0){
      state.ball.y = state.ball.r;
      state.ball.vy *= -1;
    }

    // bottom: check for paddle collision or miss
    const paddleTop = state.paddle.y;
    const paddleLeft = state.paddle.x;
    const paddleRight = state.paddle.x + state.paddle.width;
    if (state.ball.y + state.ball.r >= paddleTop){
      // if within paddle bounds horizontally and moving downward
      if (state.ball.x >= paddleLeft && state.ball.x <= paddleRight && state.ball.vy > 0){
        // bounce up
        state.ball.y = paddleTop - state.ball.r - 1;
        state.ball.vy *= -1;
        // slightly modify vx based on where it hits the paddle to add control
        const hitPos = (state.ball.x - state.paddle.x) / state.paddle.width; // 0..1
        const angle = (hitPos - 0.5) * Math.PI * 0.7; // angle influence
        const speed = Math.sqrt(state.ball.vx*state.ball.vx + state.ball.vy*state.ball.vy);
        const newSpeed = speed * 1.02; // small increase each hit
        state.ball.vx = Math.sin(angle) * newSpeed;
        state.ball.vy = -Math.abs(Math.cos(angle) * newSpeed);

        // increment score
        state.score++;
        scoreValue.textContent = state.score;

        // missions update: some missions count catches/score
        for (const m of state.missions){
          if (!m.claimed){
            if (m.title.includes('Catch') ){
              m.progress = Math.min(m.target, m.progress + 1);
            } else if (m.title.includes('Get') ){
              // 'Get 5 score' counts score as target
              m.progress = Math.min(m.target, Math.max(m.progress, state.score));
            } else if (m.title.includes('Play') ){
              // claim played game on game end; progressive tracked on end
            }
          }
        }
        saveMissions();

        // increase ball speed over time/score
        state.ball.speedMultiplier += 0.015 + state.score * 0.002;
      } else {
        // missed the paddle - end the game
        // simple miss logic: reduce life (not implemented) => for now end game
        // we can implement lives later. For now end.
        // Small delay then end
        state.running = false;
        // track play mission
        for (const m of state.missions){
          if (!m.claimed && m.title.includes('Play')){
            m.progress = Math.min(m.target, m.progress + 1);
          }
        }
        saveMissions();
        setTimeout(()=> {
          endGame();
        }, 300);
      }
    }
  }

  // draw functions
  function draw(){

    // clear canvas
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width, rect.height);

    // background (subtle gradient)
    const g = ctx.createLinearGradient(0,0,0,rect.height);
    g.addColorStop(0, 'rgba(10,20,35,0.12)');
    g.addColorStop(1, 'rgba(2,6,10,0.12)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,rect.width, rect.height);

    // draw ball
    ctx.beginPath();
    ctx.fillStyle = '#FDE68A'; // soft yellow ball
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = 8;
    ctx.arc(state.ball.x, state.ball.y, state.ball.r, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // draw paddle
    const px = state.paddle.x;
    const py = state.paddle.y;
    const pw = state.paddle.width;
    const ph = state.paddle.height;
    // paddle gradient
    const pg = ctx.createLinearGradient(px,py,px+pw,py);
    pg.addColorStop(0, '#8DD3FF');
    pg.addColorStop(1, '#1E90FF');
    ctx.fillStyle = pg;
    roundRect(ctx, px, py, pw, ph, 8);
    ctx.fill();

    // small glow under paddle
    ctx.beginPath();
    ctx.ellipse(px + pw/2, py + ph + 6, pw/2, 6, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fill();

    // optionally draw debug lines (disabled)
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  // Immediate draw in case game not running
  function drawImmediate(){
    // set paddle to center for preview
    const rect = canvas.getBoundingClientRect();
    state.paddle.width = Math.max(80, rect.width * 0.26);
    state.paddle.x = (rect.width - state.paddle.width)/2;
    state.paddle.y = rect.height - 90;
    state.ball.x = rect.width/2;
    state.ball.y = 120;
    draw();
  }

  drawImmediate();

  // main loop
  function gameLoop(timestamp){
    if (!state.running) return;
    if (state.paused){
      // show overlay
      pauseOverlay.classList.add('show');
      return;
    }
    if (!state.lastTime) state.lastTime = timestamp;
    const dt = Math.min(0.05, (timestamp - state.lastTime)/1000); // clamp dt
    state.lastTime = timestamp;

    // update & draw
    update(dt);
    draw();

    // continue
    requestAnimationFrame(gameLoop);
  }

  // Start/pause / stop interactions are handled above

  // -- Touch-to-move (drag) on canvas: allow drag paddle by touch-drag anywhere on lower half --
  let dragging = false;
  let dragOffsetX = 0;
  canvas.addEventListener('pointerdown', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const x = e.clientX - rect.left;
    // only start dragging if touching near paddle or bottom half of screen
    if (y > rect.height * 0.35){
      dragging = true;
      dragOffsetX = x - state.paddle.x;
    }
  }, {passive:true});

  canvas.addEventListener('pointermove', (e)=>{
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    state.paddle.x = x - dragOffsetX;
    // clamps
    state.paddle.x = Math.max(6, Math.min(rect.width - state.paddle.width - 6, state.paddle.x));
    draw(); // immediate feedback
  }, {passive:true});

  canvas.addEventListener('pointerup', (e)=>{
    dragging = false;
  }, {passive:true});
  canvas.addEventListener('pointercancel', (e)=>{
    dragging = false;
  }, {passive:true});

  // prevent default double tap zoom and text selection on mobile
  document.addEventListener('touchstart', (e)=> {
    if (e.touches.length > 1) e.preventDefault();
  }, {passive:false});

  // ensure first touch doesn't highlight UI
  document.addEventListener('touchmove', ()=>{}, {passive:true});

  // Save mission progress when game ends
  // Already handled at endGame

  // On load display highscore & score
  scoreValue.textContent = state.score;
  highValue.textContent = state.high;

  // ensure everything sized correctly once loaded
  window.addEventListener('load', () => {
    initSizes();
    drawImmediate();
  });

  // Expose a simple debug function to window if needed
  window._paddleQuest = {
    state,
    startGame,
    endGame,
    showScreen
  };

})();
</script>
</body>
</html>
