<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Catch the Ball!</title>
<link href="https://fonts.googleapis.com/css2?family=Lilita+One&display=swap" rel="stylesheet" />
<style>
  /* Basic reset & styling */
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  body {
    font-family: 'Lilita One', cursive;
    background: #121212;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    overflow: hidden;
  }
  h1 {
    margin: 20px 0;
    font-size: 2.5rem;
  }
  .screen {
    display: none;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 480px;
    flex-grow: 1;
    justify-content: center;
  }
  .screen.active {
    display: flex;
  }
  #gameCanvas {
    background: #222;
    border-radius: 12px;
    display: block;
    margin: 0 auto 20px;
  }
  .controls {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin-bottom: 20px;
  }
  .btn {
    background: #444;
    border-radius: 12px;
    width: 80px;
    height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    cursor: pointer;
    box-shadow: 0 0 10px #666;
    transition: background-color 0.3s ease;
  }
  .btn:active {
    background: #666;
  }
  .btn svg {
    fill: white;
    width: 40px;
    height: 40px;
  }
  button {
    font-family: 'Lilita One', cursive;
    font-size: 1.2rem;
    padding: 10px 24px;
    margin: 12px;
    border: none;
    border-radius: 10px;
    background: #e94560;
    color: white;
    cursor: pointer;
    box-shadow: 0 0 12px #e94560;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background: #d1344c;
  }
  #difficultyGrid {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
  }
  .diff {
    background: #333;
    border-radius: 10px;
    padding: 15px 25px;
    cursor: pointer;
    box-shadow: 0 0 8px #444;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  .diff.selected, .diff:hover {
    background: #e94560;
    box-shadow: 0 0 12px #e94560;
  }
  ul {
    list-style: none;
    text-align: center;
  }
  ul li {
    margin: 6px 0;
  }
</style>
</head>
<body>
  <h1>Catch the Ball!</h1>

  <!-- Home Screen -->
  <div id="homeScreen" class="screen active">
    <button id="playBtn">Play</button>
    <button id="leaderboardBtn">Leaderboard</button>
    <h3>Top Scores</h3>
    <ul id="miniLeaderboard"></ul>
  </div>

  <!-- Difficulty Selection Screen -->
  <div id="diffScreen" class="screen">
    <h2>Select Difficulty</h2>
    <div id="difficultyGrid">
      <div class="diff selected" data-diff="easy">Easy</div>
      <div class="diff" data-diff="medium">Medium</div>
      <div class="diff" data-diff="hard">Hard</div>
      <div class="diff" data-diff="super">Super Hard</div>
    </div>
    <button id="startGameBtn">Start Game</button>
    <button id="backHomeBtn">Back</button>
  </div>

  <!-- Game Screen -->
  <div id="gameScreen" class="screen" style="flex-grow:0;">
    <canvas id="gameCanvas" width="480" height="640"></canvas>
    <div class="controls">
      <div id="leftBtn" class="btn" aria-label="Move Left">
        <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"/></svg>
      </div>
      <div id="rightBtn" class="btn" aria-label="Move Right">
        <svg viewBox="0 0 24 24"><path d="M9 6l6 6-6 6"/></svg>
      </div>
    </div>
    <h3>Score: <span id="scoreDisplay">0</span></h3>
    <h4>Difficulty: <span id="diffLabel">MEDIUM</span></h4>
    <button id="retryBtn">Retry</button>
    <button id="goHomeBtn">Home</button>
  </div>

  <!-- Game Over / Leaderboard Screen -->
  <div id="overScreen" class="screen">
    <h2>Game Over</h2>
    <p>Your Score: <span id="finalScore">0</span></p>
    <button id="retryBtn2">Play Again</button>
    <button id="backHomeBtn2">Home</button>
    <h3>Leaderboard</h3>
    <ul id="leaderboardList"></ul>
  </div>

<script>
(() => {
  // SETTINGS
  const DIFFICULTY_SETTINGS = {
    easy: { startSpeed: 1.2, acceleration: 0.0015 },
    medium: { startSpeed: 1.8, acceleration: 0.0025 },
    hard: { startSpeed: 2.5, acceleration: 0.004 },
    super: { startSpeed: 3.5, acceleration: 0.006 }
  };
  const POWERUP_TYPES = ['faster', 'slow', 'shield'];
  const POWERUP_DURATION = 6000;
  const POWERUP_SPAWN_INTERVAL = 12000;

  // DOM Elements
  const homeScreen = document.getElementById('homeScreen');
  const diffScreen = document.getElementById('diffScreen');
  const gameScreen = document.getElementById('gameScreen');
  const overScreen = document.getElementById('overScreen');

  const playBtn = document.getElementById('playBtn');
  const leaderboardBtn = document.getElementById('leaderboardBtn');
  const backHomeBtn = document.getElementById('backHomeBtn');
  const startGameBtn = document.getElementById('startGameBtn');
  const retryBtn = document.getElementById('retryBtn');
  const retryBtn2 = document.getElementById('retryBtn2');
  const goHomeBtn = document.getElementById('goHomeBtn');
  const backHomeBtn2 = document.getElementById('backHomeBtn2');

  const miniLeaderboard = document.getElementById('miniLeaderboard');
  const leaderboardList = document.getElementById('leaderboardList');
  const finalScore = document.getElementById('finalScore');
  const scoreDisplay = document.getElementById('scoreDisplay');
  const diffLabel = document.getElementById('diffLabel');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const diffGrid = document.getElementById('difficultyGrid');

  // Canvas setup
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  // GAME VARIABLES
  let difficulty = 'medium';
  let ball;
  let ballDirX, ballDirY;
  let paddle;
  let paddleSpeed = 6;
  let pressedLeft = false;
  let pressedRight = false;
  let score = 0;
  let animationFrameId;
  let powerups = [];
  let activePowerups = {};
  let powerupTimers = {};
  let powerupSpawnTimer = 0;
  let shieldActive = false;

  // Helper functions
  function clamp(x, min, max) {
    return x < min ? min : x > max ? max : x;
  }

  function vibrate(pattern) {
    if (navigator.vibrate) navigator.vibrate(pattern);
  }

  // Init game state
  function init() {
    const settings = DIFFICULTY_SETTINGS[difficulty];
    ball = {
      x: width / 2,
      y: height / 2,
      radius: 12,
      speed: settings.startSpeed,
    };
    ballDirX = Math.random() < 0.5 ? -1 : 1;
    ballDirY = 1;

    paddle = {
      width: 120,
      height: 20,
      x: width / 2 - 60,
      y: height - 40,
      speed: paddleSpeed,
    };

    score = 0;
    powerups = [];
    activePowerups = {};
    powerupTimers = {};
    powerupSpawnTimer = 0;
    shieldActive = false;

    scoreDisplay.textContent = score;
    diffLabel.textContent = difficulty.toUpperCase();

    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  // Draw functions
  function draw() {
    ctx.clearRect(0, 0, width, height);

    // Ball
    ctx.beginPath();
    ctx.fillStyle = 'red';
    ctx.shadowColor = '#f87171';
    ctx.shadowBlur = 10;
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Paddle
    ctx.fillStyle = 'white';
    if (shieldActive) {
      ctx.shadowColor = '#fbbf24';
      ctx.shadowBlur = 18;
    }
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    ctx.shadowBlur = 0;

    // Powerups
    drawPowerups();
  }

  function drawPowerups() {
    powerups.forEach(p => {
      ctx.beginPath();
      switch (p.type) {
        case 'faster': ctx.fillStyle = '#22c55e'; break; // green
        case 'slow': ctx.fillStyle = '#3b82f6'; break;   // blue
        case 'shield': ctx.fillStyle = '#fbbf24'; break; // yellow
        default: ctx.fillStyle = 'white';
      }
      ctx.shadowColor = ctx.fillStyle;
      ctx.shadowBlur = 10;
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  }

  // Normalize ball direction vector (so speed is consistent)
  function normalizeBallDir() {
    const length = Math.sqrt(ballDirX * ballDirX + ballDirY * ballDirY);
    ballDirX /= length;
    ballDirY /= length;
  }

  // Update powerups with fixed redeclaration issue
  function updatePowerups() {
    const now = performance.now();

    for (let i = powerups.length - 1; i >= 0; i--) {
      const p = powerups[i];
      p.y += p.speedY;

      if (p.y - p.size > height) {
        powerups.splice(i, 1);
        continue;
      }

      if (
        p.y + p.size / 2 >= paddle.y &&
        p.x > paddle.x &&
        p.x < paddle.x + paddle.width
      ) {
        activatePowerup(p.type);
        playPickup();
        vibrate(80);
        powerups.splice(i, 1);
      }
    }

    for (const type in powerupTimers) {
      if (now - powerupTimers[type] > POWERUP_DURATION) {
        deactivatePowerup(type);
        delete powerupTimers[type];
      }
    }
  }

  // Powerup handlers
  function activatePowerup(type) {
    powerupTimers[type] = performance.now();
    activePowerups[type] = true;
    switch (type) {
      case 'faster':
        paddle.speed = paddleSpeed * 2.5;
        break;
      case 'slow':
        ball.speed /= 2;
        break;
      case 'shield':
        shieldActive = true;
        break;
    }
  }

  function deactivatePowerup(type) {
    activePowerups[type] = false;
    switch (type) {
      case 'faster':
        paddle.speed = paddleSpeed;
        break;
      case 'slow':
        ball.speed = Math.min(
          ball.speed * 2,
          DIFFICULTY_SETTINGS[difficulty].startSpeed + score * DIFFICULTY_SETTINGS[difficulty].acceleration * 1000
        );
        break;
      case 'shield':
        shieldActive = false;
        break;
    }
  }

  // Spawn powerup randomly
  function spawnPowerup() {
    const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
    const size = 14;
    powerups.push({
      x: Math.random() * (width - 2 * size) + size,
      y: -size,
      size,
      type,
      speedY: 2
    });
  }

  // Game loop
  function gameLoop() {
    // Move ball
    ball.x += ballDirX * ball.speed;
    ball.y += ballDirY * ball.speed;

    // Bounce walls left/right
    if (ball.x - ball.radius < 0) {
      ball.x = ball.radius;
      ballDirX = -ballDirX;
      playBounce();
      vibrate(30);
    } else if (ball.x + ball.radius > width) {
      ball.x = width - ball.radius;
      ballDirX = -ballDirX;
      playBounce();
      vibrate(30);
    }

    // Bounce top
    if (ball.y - ball.radius < 0) {
      ball.y = ball.radius;
      ballDirY = -ballDirY;
      playBounce();
      vibrate(30);
    }

    // Check paddle collision
    if (ball.y + ball.radius >= paddle.y) {
      if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
        ball.y = paddle.y - ball.radius;
        ballDirY = -ballDirY;

        const hitPos = (ball.x - paddle.x) / paddle.width; // 0-1
        ballDirX = (hitPos - 0.5) * 2; // -1 to 1

        normalizeBallDir();

        const maxSpeed = DIFFICULTY_SETTINGS.super.startSpeed + 6;
        ball.speed = Math.min(ball.speed + DIFFICULTY_SETTINGS[difficulty].acceleration * 10, maxSpeed);

        updateScore(score + 1);
        playBounce();
        vibrate(50);
      } else {
        // Missed paddle
        if (shieldActive) {
          ballDirY = -ballDirY;
          deactivatePowerup('shield');
          playBounce();
          vibrate([100, 50, 100]);
        } else {
          gameOver();
          return;
        }
      }
    }

    // Move paddle from inputs
    if (pressedLeft) {
      paddle.x -= paddle.speed;
    }
    if (pressedRight) {
      paddle.x += paddle.speed;
    }
    paddle.x = clamp(paddle.x, 0, width - paddle.width);

    // Spawn powerups
    powerupSpawnTimer += 16.67; // approx 60fps
    if (powerupSpawnTimer > POWERUP_SPAWN_INTERVAL) {
      spawnPowerup();
      powerupSpawnTimer = 0;
    }

    updatePowerups();
    draw();

    animationFrameId = requestAnimationFrame(gameLoop);
  }

  // Score update
  function updateScore(newScore) {
    score = newScore;
    scoreDisplay.textContent = score;
  }

  // Game over handler
  function gameOver() {
    cancelAnimationFrame(animationFrameId);
    finalScore.textContent = score;
    showScreen(overScreen);
    submitScore(score);
    loadLeaderboard();
  }

  // Show/hide screens
  function showScreen(screen) {
    [homeScreen, diffScreen, gameScreen, overScreen].forEach(s => s.classList.remove('active'));
    screen.classList.add('active');
  }

  // Controls setup
  function setupControls() {
    leftBtn.addEventListener('touchstart', e => { e.preventDefault(); pressedLeft = true; });
    leftBtn.addEventListener('touchend', e => { e.preventDefault(); pressedLeft = false; });
    leftBtn.addEventListener('touchcancel', () => { pressedLeft = false; });
    rightBtn.addEventListener('touchstart', e => { e.preventDefault(); pressedRight = true; });
    rightBtn.addEventListener('touchend', e => { e.preventDefault(); pressedRight = false; });
    rightBtn.addEventListener('touchcancel', () => { pressedRight = false; });

    // Mouse for desktop testing
    leftBtn.addEventListener('mousedown', e => { e.preventDefault(); pressedLeft = true; });
    leftBtn.addEventListener('mouseup', e => { e.preventDefault(); pressedLeft = false; });
    leftBtn.addEventListener('mouseleave', () => { pressedLeft = false; });
    rightBtn.addEventListener('mousedown', e => { e.preventDefault(); pressedRight = true; });
    rightBtn.addEventListener('mouseup', e => { e.preventDefault(); pressedRight = false; });
    rightBtn.addEventListener('mouseleave', () => { pressedRight = false; });

    // Difficulty selection clicks
    diffGrid.addEventListener('click', e => {
      const diffDiv = e.target.closest('.diff');
      if (!diffDiv) return;
      document.querySelectorAll('.diff').forEach(d => d.classList.remove('selected'));
      diffDiv.classList.add('selected');
      difficulty = diffDiv.dataset.diff;
      diffLabel.textContent = difficulty.toUpperCase();
    });
  }

  // Submit score to server
  async function submitScore(score) {
    try {
      // For simplicity, prompt player for name
      let name = prompt("Enter your name for leaderboard:", "Player");
      if (!name) name = "Player";

      await fetch('http://localhost:3000/leaderboard', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, score })
      });
    } catch (e) {
      console.error('Failed to submit score', e);
    }
  }

  // Load leaderboard from server and display
  async function loadLeaderboard() {
    try {
      const res = await fetch('http://localhost:3000/leaderboard');
      if (!res.ok) throw new Error('Failed to load leaderboard');
      const data = await res.json();

      leaderboardList.innerHTML = '';
      miniLeaderboard.innerHTML = '';
      data.slice(0, 5).forEach((entry, i) => {
        const li = document.createElement('li');
        li.textContent = `${i + 1}. ${entry.name}: ${entry.score}`;
        leaderboardList.appendChild(li);

        if (i < 3) {
          const miniLi = document.createElement('li');
          miniLi.textContent = `${entry.name}: ${entry.score}`;
          miniLeaderboard.appendChild(miniLi);
        }
      });
    } catch (e) {
      leaderboardList.innerHTML = '<li>Unable to load leaderboard</li>';
      miniLeaderboard.innerHTML = '<li>Unable to load leaderboard</li>';
    }
  }

  // Dummy sounds placeholder (can be replaced with actual sounds)
  function playBounce() {
    // Optional: Add sound effect here
  }
  function playPickup() {
    // Optional: Add sound effect here
  }

  // Button event listeners
  playBtn.addEventListener('click', () => showScreen(diffScreen));
  leaderboardBtn.addEventListener('click', () => {
    showScreen(overScreen);
    loadLeaderboard();
  });
  backHomeBtn.addEventListener('click', () => showScreen(homeScreen));
  backHomeBtn2.addEventListener('click', () => showScreen(homeScreen));
  startGameBtn.addEventListener('click', () => {
    showScreen(gameScreen);
    init();
  });
  retryBtn.addEventListener('click', () => {
    showScreen(diffScreen);
  });
  retryBtn2.addEventListener('click', () => {
    showScreen(diffScreen);
  });
  goHomeBtn.addEventListener('click', () => showScreen(homeScreen));

  // Initialize controls and leaderboard on page load
  setupControls();
  loadLeaderboard();

})();
</script>
</body>
</html>


